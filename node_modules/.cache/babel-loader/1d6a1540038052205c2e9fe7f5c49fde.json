{"ast":null,"code":"'use strict';\n\nvar base64 = require('./base64');\n\nvar fetch = require('./fetch'); // Given a regex, return a function that test if against a string\n\n\nfunction fromRegex(r) {\n  return function (o) {\n    return typeof o === 'string' && r.test(o);\n  };\n} // Try to apply a prefix to a name\n\n\nfunction prefix(pre, name) {\n  return typeof pre === 'string' ? pre + name : typeof pre === 'function' ? pre(name) : name;\n}\n/**\n * Load one or more audio files\n *\n *\n * Possible option keys:\n *\n * - __from__ {Function|String}: a function or string to convert from file names to urls.\n * If is a string it will be prefixed to the name:\n * `load(ac, 'snare.mp3', { from: 'http://audio.net/samples/' })`\n * If it's a function it receives the file name and should return the url as string.\n * - __only__ {Array} - when loading objects, if provided, only the given keys\n * will be included in the decoded object:\n * `load(ac, 'piano.json', { only: ['C2', 'D2'] })`\n *\n * @param {AudioContext} ac - the audio context\n * @param {Object} source - the object to be loaded\n * @param {Object} options - (Optional) the load options for that object\n * @param {Object} defaultValue - (Optional) the default value to return as\n * in a promise if not valid loader found\n */\n\n\nfunction load(ac, source, options, defVal) {\n  var loader = // Basic audio loading\n  isArrayBuffer(source) ? loadArrayBuffer : isAudioFileName(source) ? loadAudioFile : isPromise(source) ? loadPromise // Compound objects\n  : isArray(source) ? loadArrayData : isObject(source) ? loadObjectData : isJsonFileName(source) ? loadJsonFile // Base64 encoded audio\n  : isBase64Audio(source) ? loadBase64Audio : isJsFileName(source) ? loadMidiJSFile : null;\n  var opts = options || {};\n  return loader ? loader(ac, source, opts) : defVal ? Promise.resolve(defVal) : Promise.reject('Source not valid (' + source + ')');\n}\n\nload.fetch = fetch; // BASIC AUDIO LOADING\n// ===================\n// Load (decode) an array buffer\n\nfunction isArrayBuffer(o) {\n  return o instanceof ArrayBuffer;\n}\n\nfunction loadArrayBuffer(ac, array, options) {\n  return new Promise(function (done, reject) {\n    ac.decodeAudioData(array, function (buffer) {\n      done(buffer);\n    }, function () {\n      reject(\"Can't decode audio data (\" + array.slice(0, 30) + '...)');\n    });\n  });\n} // Load an audio filename\n\n\nvar isAudioFileName = fromRegex(/\\.(mp3|wav|ogg)(\\?.*)?$/i);\n\nfunction loadAudioFile(ac, name, options) {\n  var url = prefix(options.from, name);\n  return load(ac, load.fetch(url, 'arraybuffer'), options);\n} // Load the result of a promise\n\n\nfunction isPromise(o) {\n  return o && typeof o.then === 'function';\n}\n\nfunction loadPromise(ac, promise, options) {\n  return promise.then(function (value) {\n    return load(ac, value, options);\n  });\n} // COMPOUND OBJECTS\n// ================\n// Try to load all the items of an array\n\n\nvar isArray = Array.isArray;\n\nfunction loadArrayData(ac, array, options) {\n  return Promise.all(array.map(function (data) {\n    return load(ac, data, options, data);\n  }));\n} // Try to load all the values of a key/value object\n\n\nfunction isObject(o) {\n  return o && typeof o === 'object';\n}\n\nfunction loadObjectData(ac, obj, options) {\n  var dest = {};\n  var promises = Object.keys(obj).map(function (key) {\n    if (options.only && options.only.indexOf(key) === -1) return null;\n    var value = obj[key];\n    return load(ac, value, options, value).then(function (audio) {\n      dest[key] = audio;\n    });\n  });\n  return Promise.all(promises).then(function () {\n    return dest;\n  });\n} // Load the content of a JSON file\n\n\nvar isJsonFileName = fromRegex(/\\.json(\\?.*)?$/i);\n\nfunction loadJsonFile(ac, name, options) {\n  var url = prefix(options.from, name);\n  return load(ac, load.fetch(url, 'text').then(JSON.parse), options);\n} // BASE64 ENCODED FORMATS\n// ======================\n// Load strings with Base64 encoded audio\n\n\nvar isBase64Audio = fromRegex(/^data:audio/);\n\nfunction loadBase64Audio(ac, source, options) {\n  var i = source.indexOf(',');\n  return load(ac, base64.decode(source.slice(i + 1)).buffer, options);\n} // Load .js files with MidiJS soundfont prerendered audio\n\n\nvar isJsFileName = fromRegex(/\\.js(\\?.*)?$/i);\n\nfunction loadMidiJSFile(ac, name, options) {\n  var url = prefix(options.from, name);\n  return load(ac, load.fetch(url, 'text').then(midiJsToJson), options);\n} // convert a MIDI.js javascript soundfont file to json\n\n\nfunction midiJsToJson(data) {\n  var begin = data.indexOf('MIDI.Soundfont.');\n  if (begin < 0) throw Error('Invalid MIDI.js Soundfont format');\n  begin = data.indexOf('=', begin) + 2;\n  var end = data.lastIndexOf(',');\n  return JSON.parse(data.slice(begin, end) + '}');\n}\n\nif (typeof module === 'object' && module.exports) module.exports = load;\nif (typeof window !== 'undefined') window.loadAudio = load;","map":null,"metadata":{},"sourceType":"script"}