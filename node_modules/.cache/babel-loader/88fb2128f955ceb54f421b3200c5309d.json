{"ast":null,"code":"'use strict'; // util\n\nfunction fillStr(s, num) {\n  return Array(num + 1).join(s);\n}\n\nfunction isNum(x) {\n  return typeof x === 'number';\n}\n\nfunction isStr(x) {\n  return typeof x === 'string';\n}\n\nfunction isDef(x) {\n  return typeof x !== 'undefined';\n}\n\nfunction midiToFreq(midi, tuning) {\n  return Math.pow(2, (midi - 69) / 12) * (tuning || 440);\n}\n\nvar REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)\\s*$/;\n/**\n * A regex for matching note strings in scientific notation.\n *\n * @name regex\n * @function\n * @return {RegExp} the regexp used to parse the note name\n *\n * The note string should have the form `letter[accidentals][octave][element]`\n * where:\n *\n * - letter: (Required) is a letter from A to G either upper or lower case\n * - accidentals: (Optional) can be one or more `b` (flats), `#` (sharps) or `x` (double sharps).\n * They can NOT be mixed.\n * - octave: (Optional) a positive or negative integer\n * - element: (Optional) additionally anything after the duration is considered to\n * be the element name (for example: 'C2 dorian')\n *\n * The executed regex contains (by array index):\n *\n * - 0: the complete string\n * - 1: the note letter\n * - 2: the optional accidentals\n * - 3: the optional octave\n * - 4: the rest of the string (trimmed)\n *\n * @example\n * var parser = require('note-parser')\n * parser.regex.exec('c#4')\n * // => ['c#4', 'c', '#', '4', '']\n * parser.regex.exec('c#4 major')\n * // => ['c#4major', 'c', '#', '4', 'major']\n * parser.regex().exec('CMaj7')\n * // => ['CMaj7', 'C', '', '', 'Maj7']\n */\n\nexport function regex() {\n  return REGEX;\n}\nvar SEMITONES = [0, 2, 4, 5, 7, 9, 11];\n/**\n * Parse a note name in scientific notation an return it's components,\n * and some numeric properties including midi number and frequency.\n *\n * @name parse\n * @function\n * @param {String} note - the note string to be parsed\n * @param {Boolean} isTonic - true the strings it's supposed to contain a note number\n * and some category (for example an scale: 'C# major'). It's false by default,\n * but when true, en extra tonicOf property is returned with the category ('major')\n * @param {Float} tunning - The frequency of A4 note to calculate frequencies.\n * By default it 440.\n * @return {Object} the parsed note name or null if not a valid note\n *\n * The parsed note name object will ALWAYS contains:\n * - letter: the uppercase letter of the note\n * - acc: the accidentals of the note (only sharps or flats)\n * - pc: the pitch class (letter + acc)\n * - step: s a numeric representation of the letter. It's an integer from 0 to 6\n * where 0 = C, 1 = D ... 6 = B\n * - alt: a numeric representation of the accidentals. 0 means no alteration,\n * positive numbers are for sharps and negative for flats\n * - chroma: a numeric representation of the pitch class. It's like midi for\n * pitch classes. 0 = C, 1 = C#, 2 = D ... 11 = B. Can be used to find enharmonics\n * since, for example, chroma of 'Cb' and 'B' are both 11\n *\n * If the note has octave, the parser object will contain:\n * - oct: the octave number (as integer)\n * - midi: the midi number\n * - freq: the frequency (using tuning parameter as base)\n *\n * If the parameter `isTonic` is set to true, the parsed object will contain:\n * - tonicOf: the rest of the string that follows note name (left and right trimmed)\n *\n * @example\n * var parse = require('note-parser').parse\n * parse('Cb4')\n * // => { letter: 'C', acc: 'b', pc: 'Cb', step: 0, alt: -1, chroma: -1,\n *         oct: 4, midi: 59, freq: 246.94165062806206 }\n * // if no octave, no midi, no freq\n * parse('fx')\n * // => { letter: 'F', acc: '##', pc: 'F##', step: 3, alt: 2, chroma: 7 })\n */\n\nexport function parse(str, isTonic, tuning) {\n  if (typeof str !== 'string') return null;\n  var m = REGEX.exec(str);\n  if (!m || !isTonic && m[4]) return null;\n  var p = {\n    letter: m[1].toUpperCase(),\n    acc: m[2].replace(/x/g, '##')\n  };\n  p.pc = p.letter + p.acc;\n  p.step = (p.letter.charCodeAt(0) + 3) % 7;\n  p.alt = p.acc[0] === 'b' ? -p.acc.length : p.acc.length;\n  var pos = SEMITONES[p.step] + p.alt;\n  p.chroma = pos < 0 ? 12 + pos : pos % 12;\n\n  if (m[3]) {\n    // has octave\n    p.oct = +m[3];\n    p.midi = pos + 12 * (p.oct + 1);\n    p.freq = midiToFreq(p.midi, tuning);\n  }\n\n  if (isTonic) p.tonicOf = m[4];\n  return p;\n}\nvar LETTERS = 'CDEFGAB';\n\nfunction accStr(n) {\n  return !isNum(n) ? '' : n < 0 ? fillStr('b', -n) : fillStr('#', n);\n}\n\nfunction octStr(n) {\n  return !isNum(n) ? '' : '' + n;\n}\n/**\n * Create a string from a parsed object or `step, alteration, octave` parameters\n * @param {Object} obj - the parsed data object\n * @return {String} a note string or null if not valid parameters\n * @since 1.2\n * @example\n * parser.build(parser.parse('cb2')) // => 'Cb2'\n *\n * @example\n * // it accepts (step, alteration, octave) parameters:\n * parser.build(3) // => 'F'\n * parser.build(3, -1) // => 'Fb'\n * parser.build(3, -1, 4) // => 'Fb4'\n */\n\n\nexport function build(s, a, o) {\n  if (s === null || typeof s === 'undefined') return null;\n  if (s.step) return build(s.step, s.alt, s.oct);\n  if (s < 0 || s > 6) return null;\n  return LETTERS.charAt(s) + accStr(a) + octStr(o);\n}\n/**\n * Get midi of a note\n *\n * @name midi\n * @function\n * @param {String|Integer} note - the note name or midi number\n * @return {Integer} the midi number of the note or null if not a valid note\n * or the note does NOT contains octave\n * @example\n * var parser = require('note-parser')\n * parser.midi('A4') // => 69\n * parser.midi('A') // => null\n * @example\n * // midi numbers are bypassed (even as strings)\n * parser.midi(60) // => 60\n * parser.midi('60') // => 60\n */\n\nexport function midi(note) {\n  if ((isNum(note) || isStr(note)) && note >= 0 && note < 128) return +note;\n  var p = parse(note);\n  return p && isDef(p.midi) ? p.midi : null;\n}\n/**\n * Get freq of a note in hertzs (in a well tempered 440Hz A4)\n *\n * @name freq\n * @function\n * @param {String} note - the note name or note midi number\n * @param {String} tuning - (Optional) the A4 frequency (440 by default)\n * @return {Float} the freq of the number if hertzs or null if not valid note\n * @example\n * var parser = require('note-parser')\n * parser.freq('A4') // => 440\n * parser.freq('A') // => null\n * @example\n * // can change tuning (440 by default)\n * parser.freq('A4', 444) // => 444\n * parser.freq('A3', 444) // => 222\n * @example\n * // it accepts midi numbers (as numbers and as strings)\n * parser.freq(69) // => 440\n * parser.freq('69', 442) // => 442\n */\n\nexport function freq(note, tuning) {\n  var m = midi(note);\n  return m === null ? null : midiToFreq(m, tuning);\n}\nexport function letter(src) {\n  return (parse(src) || {}).letter;\n}\nexport function acc(src) {\n  return (parse(src) || {}).acc;\n}\nexport function pc(src) {\n  return (parse(src) || {}).pc;\n}\nexport function step(src) {\n  return (parse(src) || {}).step;\n}\nexport function alt(src) {\n  return (parse(src) || {}).alt;\n}\nexport function chroma(src) {\n  return (parse(src) || {}).chroma;\n}\nexport function oct(src) {\n  return (parse(src) || {}).oct;\n}","map":null,"metadata":{},"sourceType":"module"}